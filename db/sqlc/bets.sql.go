// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: bets.sql

package db

import (
	"context"
)

const createBet = `-- name: CreateBet :one
INSERT INTO bets (user_id, match_id, bet_points, bet_result) VALUES ($1, $2, $3, $4) RETURNING bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value
`

type CreateBetParams struct {
	UserID    *int32
	MatchID   *int32
	BetPoints int32
	BetResult *bool
}

func (q *Queries) CreateBet(ctx context.Context, arg CreateBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, createBet,
		arg.UserID,
		arg.MatchID,
		arg.BetPoints,
		arg.BetResult,
	)
	var i Bet
	err := row.Scan(
		&i.BetID,
		&i.UserID,
		&i.MatchID,
		&i.BetPoints,
		&i.BetResult,
		&i.BetDate,
		&i.BetValue,
	)
	return i, err
}

const deleteBet = `-- name: DeleteBet :one
DELETE FROM bets WHERE bet_id = $1 RETURNING bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value
`

func (q *Queries) DeleteBet(ctx context.Context, betID int32) (Bet, error) {
	row := q.db.QueryRow(ctx, deleteBet, betID)
	var i Bet
	err := row.Scan(
		&i.BetID,
		&i.UserID,
		&i.MatchID,
		&i.BetPoints,
		&i.BetResult,
		&i.BetDate,
		&i.BetValue,
	)
	return i, err
}

const getBet = `-- name: GetBet :one
SELECT bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value FROM bets WHERE bet_id = $1
`

func (q *Queries) GetBet(ctx context.Context, betID int32) (Bet, error) {
	row := q.db.QueryRow(ctx, getBet, betID)
	var i Bet
	err := row.Scan(
		&i.BetID,
		&i.UserID,
		&i.MatchID,
		&i.BetPoints,
		&i.BetResult,
		&i.BetDate,
		&i.BetValue,
	)
	return i, err
}

const getBetsByMatch = `-- name: GetBetsByMatch :many
SELECT bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value FROM bets WHERE match_id = $1
`

func (q *Queries) GetBetsByMatch(ctx context.Context, matchID *int32) ([]Bet, error) {
	rows, err := q.db.Query(ctx, getBetsByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bet
	for rows.Next() {
		var i Bet
		if err := rows.Scan(
			&i.BetID,
			&i.UserID,
			&i.MatchID,
			&i.BetPoints,
			&i.BetResult,
			&i.BetDate,
			&i.BetValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetsByUser = `-- name: GetBetsByUser :many
SELECT bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value FROM bets WHERE user_id = $1
`

func (q *Queries) GetBetsByUser(ctx context.Context, userID *int32) ([]Bet, error) {
	rows, err := q.db.Query(ctx, getBetsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bet
	for rows.Next() {
		var i Bet
		if err := rows.Scan(
			&i.BetID,
			&i.UserID,
			&i.MatchID,
			&i.BetPoints,
			&i.BetResult,
			&i.BetDate,
			&i.BetValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetsByUserAndMatch = `-- name: GetBetsByUserAndMatch :many
SELECT bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value FROM bets WHERE user_id = $1 AND match_id = $2
`

type GetBetsByUserAndMatchParams struct {
	UserID  *int32
	MatchID *int32
}

func (q *Queries) GetBetsByUserAndMatch(ctx context.Context, arg GetBetsByUserAndMatchParams) ([]Bet, error) {
	rows, err := q.db.Query(ctx, getBetsByUserAndMatch, arg.UserID, arg.MatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bet
	for rows.Next() {
		var i Bet
		if err := rows.Scan(
			&i.BetID,
			&i.UserID,
			&i.MatchID,
			&i.BetPoints,
			&i.BetResult,
			&i.BetDate,
			&i.BetValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBet = `-- name: UpdateBet :one
UPDATE bets SET user_id = $2, match_id = $3, bet_points = $4, bet_result = $5 WHERE bet_id = $1 RETURNING bet_id, user_id, match_id, bet_points, bet_result, bet_date, bet_value
`

type UpdateBetParams struct {
	BetID     int32
	UserID    *int32
	MatchID   *int32
	BetPoints int32
	BetResult *bool
}

func (q *Queries) UpdateBet(ctx context.Context, arg UpdateBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, updateBet,
		arg.BetID,
		arg.UserID,
		arg.MatchID,
		arg.BetPoints,
		arg.BetResult,
	)
	var i Bet
	err := row.Scan(
		&i.BetID,
		&i.UserID,
		&i.MatchID,
		&i.BetPoints,
		&i.BetResult,
		&i.BetDate,
		&i.BetValue,
	)
	return i, err
}
