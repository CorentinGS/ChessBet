// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"
	"time"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (tournament_id, player1_id, player2_id,
 match_date, round_name, lichess_round_id, lichess_game_id, match_result) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

type CreateMatchParams struct {
	TournamentID   *int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
		arg.RoundName,
		arg.LichessRoundID,
		arg.LichessGameID,
		arg.MatchResult,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

type CreateMatchesParams struct {
	TournamentID   *int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

const deleteMatch = `-- name: DeleteMatch :one
DELETE FROM matches WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

func (q *Queries) DeleteMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, deleteMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

const getCurrentMatchesByTournament = `-- name: GetCurrentMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1 AND match_date = CURRENT_DATE
`

func (q *Queries) GetCurrentMatchesByTournament(ctx context.Context, tournamentID *int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getCurrentMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatch = `-- name: GetMatch :one
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE match_id = $1
`

func (q *Queries) GetMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

const getMatches = `-- name: GetMatches :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches
`

func (q *Queries) GetMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByDate = `-- name: GetMatchesByDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE match_date = $1
`

func (q *Queries) GetMatchesByDate(ctx context.Context, matchDate time.Time) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByDate, matchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByPlayer = `-- name: GetMatchesByPlayer :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE player1_id = $1 OR player2_id = $1
`

func (q *Queries) GetMatchesByPlayer(ctx context.Context, player1ID int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByPlayer, player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByPlayerAndDate = `-- name: GetMatchesByPlayerAndDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE (player1_id = $1 OR player2_id = $1) AND match_date = $2
`

type GetMatchesByPlayerAndDateParams struct {
	Player1ID int32
	MatchDate time.Time
}

func (q *Queries) GetMatchesByPlayerAndDate(ctx context.Context, arg GetMatchesByPlayerAndDateParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByPlayerAndDate, arg.Player1ID, arg.MatchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournament = `-- name: GetMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1
`

func (q *Queries) GetMatchesByTournament(ctx context.Context, tournamentID *int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournamentAndDate = `-- name: GetMatchesByTournamentAndDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1 AND match_date = $2
`

type GetMatchesByTournamentAndDateParams struct {
	TournamentID *int32
	MatchDate    time.Time
}

func (q *Queries) GetMatchesByTournamentAndDate(ctx context.Context, arg GetMatchesByTournamentAndDateParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournamentAndDate, arg.TournamentID, arg.MatchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournamentAndPlayer = `-- name: GetMatchesByTournamentAndPlayer :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1 AND (player1_id = $2 OR player2_id = $2)
`

type GetMatchesByTournamentAndPlayerParams struct {
	TournamentID *int32
	Player1ID    int32
}

func (q *Queries) GetMatchesByTournamentAndPlayer(ctx context.Context, arg GetMatchesByTournamentAndPlayerParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournamentAndPlayer, arg.TournamentID, arg.Player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastMatchesByTournament = `-- name: GetPastMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1 AND match_date < CURRENT_DATE
`

func (q *Queries) GetPastMatchesByTournament(ctx context.Context, tournamentID *int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getPastMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingMatchesByTournament = `-- name: GetUpcomingMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE tournament_id = $1 AND match_date > CURRENT_DATE
`

func (q *Queries) GetUpcomingMatchesByTournament(ctx context.Context, tournamentID *int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getUpcomingMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches SET tournament_id = $2, player1_id = $3, player2_id = $4,
 match_date = $5, round_name = $6, lichess_round_id = $7, lichess_game_id = $8, match_result = $9 WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

type UpdateMatchParams struct {
	MatchID        int32
	TournamentID   *int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatch,
		arg.MatchID,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
		arg.RoundName,
		arg.LichessRoundID,
		arg.LichessGameID,
		arg.MatchResult,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}
