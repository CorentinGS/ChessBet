// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"
	"time"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (tournament_id, player1_id, player2_id,
 match_date, round_name, lichess_round_id, lichess_game_id, match_result) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

type CreateMatchParams struct {
	TournamentID   int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
		arg.RoundName,
		arg.LichessRoundID,
		arg.LichessGameID,
		arg.MatchResult,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

type CreateMatchesParams struct {
	TournamentID   int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

const deleteMatch = `-- name: DeleteMatch :one
DELETE FROM matches WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

func (q *Queries) DeleteMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, deleteMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

const getMatch = `-- name: GetMatch :one
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches WHERE match_id = $1
`

func (q *Queries) GetMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}

const getMatches = `-- name: GetMatches :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result FROM matches
`

func (q *Queries) GetMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingMatchesByTournament = `-- name: GetUpcomingMatchesByTournament :many
SELECT matches.match_id, matches.tournament_id, matches.player1_id, matches.player2_id, matches.match_date, matches.round_name, matches.lichess_round_id, matches.lichess_game_id, matches.match_result, player1.player_id, player1.name, player1.rating, player1.image_url, player2.player_id, player2.name, player2.rating, player2.image_url
FROM matches 
JOIN players AS player1 ON matches.player1_id = player1.player_id
JOIN players AS player2 ON matches.player2_id = player2.player_id
WHERE matches.tournament_id = $1 AND matches.match_date >= NOW()
GROUP BY matches.match_id, matches.lichess_round_id, player1.player_id, player2.player_id
ORDER BY matches.match_date ASC
`

type GetUpcomingMatchesByTournamentRow struct {
	MatchID        int32
	TournamentID   int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
	PlayerID       int32
	Name           string
	Rating         int32
	ImageUrl       *string
	PlayerID_2     int32
	Name_2         string
	Rating_2       int32
	ImageUrl_2     *string
}

func (q *Queries) GetUpcomingMatchesByTournament(ctx context.Context, tournamentID int32) ([]GetUpcomingMatchesByTournamentRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingMatchesByTournamentRow
	for rows.Next() {
		var i GetUpcomingMatchesByTournamentRow
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
			&i.RoundName,
			&i.LichessRoundID,
			&i.LichessGameID,
			&i.MatchResult,
			&i.PlayerID,
			&i.Name,
			&i.Rating,
			&i.ImageUrl,
			&i.PlayerID_2,
			&i.Name_2,
			&i.Rating_2,
			&i.ImageUrl_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches SET tournament_id = $2, player1_id = $3, player2_id = $4,
 match_date = $5, round_name = $6, lichess_round_id = $7, lichess_game_id = $8, match_result = $9 WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date, round_name, lichess_round_id, lichess_game_id, match_result
`

type UpdateMatchParams struct {
	MatchID        int32
	TournamentID   int32
	Player1ID      int32
	Player2ID      int32
	MatchDate      time.Time
	RoundName      string
	LichessRoundID string
	LichessGameID  *string
	MatchResult    *int32
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatch,
		arg.MatchID,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
		arg.RoundName,
		arg.LichessRoundID,
		arg.LichessGameID,
		arg.MatchResult,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
		&i.RoundName,
		&i.LichessRoundID,
		&i.LichessGameID,
		&i.MatchResult,
	)
	return i, err
}
