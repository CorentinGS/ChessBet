// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (tournament_id, player1_id, player2_id, match_date) VALUES ($1, $2, $3, $4) RETURNING match_id, tournament_id, player1_id, player2_id, match_date
`

type CreateMatchParams struct {
	TournamentID pgtype.Int4
	Player1ID    int32
	Player2ID    int32
	MatchDate    time.Time
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
	)
	return i, err
}

const deleteMatch = `-- name: DeleteMatch :one
DELETE FROM matches WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date
`

func (q *Queries) DeleteMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, deleteMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
	)
	return i, err
}

const getCurrentMatchesByTournament = `-- name: GetCurrentMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1 AND match_date = CURRENT_DATE
`

func (q *Queries) GetCurrentMatchesByTournament(ctx context.Context, tournamentID pgtype.Int4) ([]Match, error) {
	rows, err := q.db.Query(ctx, getCurrentMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatch = `-- name: GetMatch :one
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE match_id = $1
`

func (q *Queries) GetMatch(ctx context.Context, matchID int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
	)
	return i, err
}

const getMatches = `-- name: GetMatches :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches
`

func (q *Queries) GetMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByDate = `-- name: GetMatchesByDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE match_date = $1
`

func (q *Queries) GetMatchesByDate(ctx context.Context, matchDate time.Time) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByDate, matchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByPlayer = `-- name: GetMatchesByPlayer :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE player1_id = $1 OR player2_id = $1
`

func (q *Queries) GetMatchesByPlayer(ctx context.Context, player1ID int32) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByPlayer, player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByPlayerAndDate = `-- name: GetMatchesByPlayerAndDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE (player1_id = $1 OR player2_id = $1) AND match_date = $2
`

type GetMatchesByPlayerAndDateParams struct {
	Player1ID int32
	MatchDate time.Time
}

func (q *Queries) GetMatchesByPlayerAndDate(ctx context.Context, arg GetMatchesByPlayerAndDateParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByPlayerAndDate, arg.Player1ID, arg.MatchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournament = `-- name: GetMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1
`

func (q *Queries) GetMatchesByTournament(ctx context.Context, tournamentID pgtype.Int4) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournamentAndDate = `-- name: GetMatchesByTournamentAndDate :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1 AND match_date = $2
`

type GetMatchesByTournamentAndDateParams struct {
	TournamentID pgtype.Int4
	MatchDate    time.Time
}

func (q *Queries) GetMatchesByTournamentAndDate(ctx context.Context, arg GetMatchesByTournamentAndDateParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournamentAndDate, arg.TournamentID, arg.MatchDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournamentAndPlayer = `-- name: GetMatchesByTournamentAndPlayer :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1 AND (player1_id = $2 OR player2_id = $2)
`

type GetMatchesByTournamentAndPlayerParams struct {
	TournamentID pgtype.Int4
	Player1ID    int32
}

func (q *Queries) GetMatchesByTournamentAndPlayer(ctx context.Context, arg GetMatchesByTournamentAndPlayerParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, getMatchesByTournamentAndPlayer, arg.TournamentID, arg.Player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastMatchesByTournament = `-- name: GetPastMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1 AND match_date < CURRENT_DATE
`

func (q *Queries) GetPastMatchesByTournament(ctx context.Context, tournamentID pgtype.Int4) ([]Match, error) {
	rows, err := q.db.Query(ctx, getPastMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingMatchesByTournament = `-- name: GetUpcomingMatchesByTournament :many
SELECT match_id, tournament_id, player1_id, player2_id, match_date FROM matches WHERE tournament_id = $1 AND match_date > CURRENT_DATE
`

func (q *Queries) GetUpcomingMatchesByTournament(ctx context.Context, tournamentID pgtype.Int4) ([]Match, error) {
	rows, err := q.db.Query(ctx, getUpcomingMatchesByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.TournamentID,
			&i.Player1ID,
			&i.Player2ID,
			&i.MatchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches SET tournament_id = $2, player1_id = $3, player2_id = $4, match_date = $5 WHERE match_id = $1 RETURNING match_id, tournament_id, player1_id, player2_id, match_date
`

type UpdateMatchParams struct {
	MatchID      int32
	TournamentID pgtype.Int4
	Player1ID    int32
	Player2ID    int32
	MatchDate    time.Time
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatch,
		arg.MatchID,
		arg.TournamentID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchDate,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.TournamentID,
		&i.Player1ID,
		&i.Player2ID,
		&i.MatchDate,
	)
	return i, err
}
